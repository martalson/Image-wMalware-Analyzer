#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <zlib.h>
#include "png.h"




void free_ptrs(unsigned char* ptr1, unsigned char* ptr2, unsigned char* ptr3 , unsigned char* ptr4);

unsigned int change_endianness(unsigned char *n){
    unsigned int bytes_one = n[3];
    unsigned int bytes_two = n[2];
    unsigned int bytes_three = n[1];
    unsigned int bytes_four = n[0];
    unsigned int l = bytes_one + (bytes_two << 8) + (bytes_three << 16) + (bytes_four << 24);
    return l;
  }


/*
 * Classify a chunk
 * If chunk matches type, return 1 == true
 * Return 0 otherwise 
 */

 int chunk_classifier(unsigned char *chun, unsigned char *type){
 	int i = 0;
 	while(i <= 3){
		if (chun[i] == type[i]){
			if(i == 3){
				return 1;
			}
			i++;
			continue;
		}

		return 0;
	}
	return 0;

 }



 void print_text(unsigned char * data, unsigned int *length){
 	unsigned int p = 0;
    unsigned char key[*length + 1];
	while(p < *length && (data[p] != 0)){
      	key[p] = data[p];
      	p++;
	}
	    key[p]= 0;
		p++;
        printf("%s: ", key);
		while(p < *length)
		{
		printf("%.*s", 1, data + p);
		p++;
		}
		printf("\n");
 }

void print_ztxt(unsigned char * data, unsigned int *length){
	unsigned int p = 0;
	unsigned char* key = malloc(sizeof(unsigned char)*(*length) + 1);

  if(!key){
    return;
  }
	while(p < *length && data[p] != 0) {
	   	key[p] = data[p];
 		p++;
	}
  
	key[p] = 0; 

	printf("%s: ", key);
	free(key);
	p++;


	if(p < *length && data[p] == 0){
		p++;
	    if(p < *length){
		unsigned long *size = malloc(sizeof(unsigned long));
		*size = 1000;
       

		unsigned char * compressed = malloc(*length-p);
		memcpy(compressed, &data[p], *length-p);

		unsigned char * holder = malloc(*size + 1);

        unsigned long msg = uncompress((Bytef*) holder, size ,compressed,*length - p);
        int i = 0;
        holder[*size] = 0;
        	i++;    
        if((long)msg == -5){
          free(holder);
			while(((long)msg) == -5){//double the size of the array until everything fits
				*size = *size *2;
           		 unsigned char * holder = (unsigned char*)malloc(*size);
        		msg = uncompress((Bytef*) holder, size ,(Bytef*)&data[p],*length-p);
        	if((long)msg<0 && (long) msg != -5){
        		free(holder);
                free(compressed);
                free(size);
                return;
        	}
            if((long) msg == -5){
                free(holder);
            }
        	}
        }
		unsigned long u = 0;
        if(!size || !*size){
            return;
        }
		while (u < *size){
			printf("%.*s",1, holder + u);
			u++;
		}
		printf("\n");
		free(size);
		free(compressed);
		free(holder);
        }
	}
}

void print_time(unsigned char* data,unsigned int* new_len){

    if(*new_len != 7){ // invalid time, should be of length 7.
            return;
        }
        unsigned int year = (((unsigned int) data[0]) << 8 ) + (unsigned int) data[1];
        unsigned int month = data[2];
        unsigned int day = data[3];
        unsigned int hour = data[4];
        unsigned int minute = data[5];
        unsigned int second = data[6];
        printf("Timestamp: %d/%d/%d %d:%d:%d\n", month, day, year, hour, minute, second);
}

int integrity(unsigned char* data, unsigned char * chunk, unsigned int* checksum, unsigned int* new_len){
     unsigned int new_checksum = crc32(0, Z_NULL, 0);
     new_checksum = crc32(new_checksum,chunk, 4);
     new_checksum = crc32(new_checksum, data, *new_len);

  
     free(data);
     free(chunk);
     if(new_checksum != *checksum){
        return 0; // corrupted data, exit integrity == false
    }
    return 1; //integrity == true
}

int analyze_body(FILE* f, int current_pos, int file_size, unsigned char* Text, unsigned char* Ztxt, unsigned char* Time, unsigned char* Iend){
    
    typedef int bool;

    #define true 1
    #define false 0

    bool time_valid = true;
    size_t correct = 0; //size that should be read
    size_t result = 0; //number of bytes read
    while(true){


    unsigned char *length = malloc(4* sizeof(char));
    result = fread(length, 1, 4, f);

    current_pos += 4;
    correct = 4;
    unsigned int new_len = change_endianness(length);
    free(length);
    if (result < correct || current_pos >file_size){
        return 2;
     }
  

    unsigned char * chunk = malloc(4* sizeof(char));
    
    result = fread(chunk, 1, 4, f);
    current_pos += 4;

    unsigned char *data = malloc(1 + new_len*(sizeof(unsigned char)));

   
    if (result != 4 || current_pos > file_size){ //did not read the entire chunk
        free(chunk);
        free(data);
        return 2;
    }
    if (!data){
        free(chunk);
        return 2;
    }
    
    if(chunk_classifier(chunk, Iend)){
        free(chunk);
        free(data);
        return 2;
    }
    result = fread(data, 1, new_len, f);
    
    current_pos += new_len;
    unsigned char * unordered_checksum = malloc(sizeof(char) * 4);
    
     if (result != new_len || current_pos > file_size){ //did not read the entire chunk
      free(chunk);
        free(data);
        if(unordered_checksum){
        free(unordered_checksum);
        }
        return 2;
    }
    if (!unordered_checksum){ 
        free(chunk);
        free(data);
        return 2;
    }
    
    fread(unordered_checksum, 1, 4, f);

    current_pos += 4;

    unsigned int checksum = change_endianness(unordered_checksum);
    
    free(unordered_checksum);
    if (current_pos > file_size){ 
        free(chunk);
        free(data);
        return 2;
    }

    if(chunk_classifier(chunk,Text)){ //the chunk is Text
        print_text(data, &new_len);
    }

    else if(chunk_classifier(chunk, Ztxt)){ //the chunk is Ztxt
        print_ztxt(data, &new_len);

    }
    else if((chunk_classifier(chunk, Time)) && time_valid){ //the chunk is the Time
        time_valid = false; //cannot be more than one valid time.
        print_time(data, &new_len);
    }
     if(!integrity(data, chunk, &checksum, &new_len)){
        return 2;
     }
    }

}

/*
 * Analyze a PNG file.
 * If it is a PNG file, print out all relevant metadata and return 0.
 * If it isn't a PNG file, return -1 and print nothing.
 */
int analyze_png(FILE *f) {
    if(f == 0) return -1;
    
    int header_length = 8;
    unsigned char header[header_length];
    

    int current_pos = ftell(f);
    fseek(f, 0, SEEK_END);
    int file_size = ftell(f);
    fseek(f,0, current_pos);
 

    size_t result = fread(header, 1, 8, f);
    current_pos += 8;
    if(current_pos > file_size){return 2;}

    size_t correct = 8;
    
    if(result< correct){
		return -1;
	} 
    unsigned char png[] = {0x89, 0x50, 0x4e, 0x47,0x0d,0x0a,0x1a,0x0a};
    
    int i = header_length - 1;
    while(i){
     if(header[i] != png[i]){  
        return -1;
     }
    i--;
    }
    
    unsigned char *Text = malloc( 4 * sizeof(char));
    unsigned char *Ztxt = malloc( 4 * sizeof(char));
    unsigned char *Time = malloc( 4 * sizeof(char));
    unsigned char *Iend = malloc( 4 * sizeof(char));
    Text[0] = 0x74, Text[1] = 0x45, Text[2] = 0x58, Text[3] = 0x74;
    Ztxt[0] = 0x7a, Ztxt[1] = 0x54, Ztxt[2] = 0x58, Ztxt[3] = 0x74;
    Time[0] = 0x74, Time[1] = 0x49, Time[2] = 0x4d, Time[3] = 0x45;
    Iend[0] = 0x49, Iend[1] = 0x45, Iend[2] = 0x4e, Iend[3] = 0x44;
    analyze_body(f, current_pos, file_size, Text, Ztxt, Time, Iend);
    free_ptrs(Time,Iend,Ztxt,Text);
    return 0;
    
}

void free_ptrs(unsigned char* ptr1, unsigned char* ptr2, unsigned char* ptr3, unsigned char* ptr4){
	free(ptr1);
	free(ptr2);
	free(ptr3);
	free(ptr4);
}


